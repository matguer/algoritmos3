\subsection{B\'usqueda Local}

Una heur\'istica de b\'usqueda local toma una soluci\'on inicial $s$, obtenida por ejemplo a partir de una heur\'istica constructiva. Luego, en cada iteraci\'on la mejora reemplaz\'andola por otra soluci\'on, perteneciente al conjunto de soluciones vecinas de $s$. El procedimiento se repite hasta alcanzar un \'optimo local.\\
El siguiente es un esquema general de esta heur\'istica:\\
Componentes principales

\begin{itemize}
\item S = conjunto de soluciones
\item N(s) = soluciones vecinas de s
\item f(s) = valor de la soluci\'on s
\end{itemize}

Forma del algoritmo
\begin{itemize}
\item elegir una soluci\'on s $\in$ S (soluci\'on inicial)
\item mientras exista s' $\in$ N(s) donde f(s') $<$ f(s)
\begin{itemize}
	\item reemplazar s por s'
\end{itemize}
\item devolver s
\end{itemize}

\subsection{Descripci\'on del algoritmo}

Analicemos la heur\'istica de b\'usqueda local propuesta utilizando como gu\'ia el esquema general descripto en la secci\'on anterior.\\

Componentes principales
\begin{itemize}
\item S = conjunto de soluciones. En este caso, el conjunto de soluciones est\'a representado por todos los caminos entre $u$ y $v$ del grafo, que est\'en acotados por $K$ en $w_1$ y sean m\'inimos en $w_2$.
\item N(s) = soluciones vecinas de s. Dos soluciones son vecinas si comparten el camino de $u$ a $w$ o de $w$ a $v$, donde $w$ es un nodo perteneciente al camino soluci\'on inicial. 
\item f(s) = valor de la soluci\'on s. El valor de una soluci\'on s est\'a dado por su valor en $w_1$ y su valor en $w_2$.
\end{itemize}

Como soluci\'on inicial usamos el camino m\'inimo en $w_1$ entre $u$ y $v$, generado utilizando el algoritmo de Floyd.\\
En un principio consideramos usar tanto el camino m\'inimo en $w_1$ como el de $w_2$, pero finalmente nos decidimos por el de $w_1$ ya que, por como definimos la vecindad de una soluci\'on, si tom\'aramos el m\'inimo en $w_2$, ser\'ia probable que no est\'e acotado por $K$ y, peor a\'un, todos sus vecinos podr\'ian estar muy por arriba de esa cota. As\'i, el algoritmo devolver\'ia una soluci\'on que ni siquiera es aproximada, ya que no estar\'ia acotada por $K$ y, por lo tanto, no ser\'ia ni la m\'inima ni una cercana a la m\'inima de las acotadas por ese n\'umero.\\
En cambio, tomando como base la m\'as chica en $w_1$ y suponiendo que la misma est\'a acotada por $K$ (en otro caso no existe soluci\'on para el problema); aunque al final el algoritmo no nos diera la soluci\'on exacta, tendr\'iamos al menos una buena aproximaci\'on, que seguro va a estar acotada por $K$ y que es la m\'inima entre sus vecinos (local) en $w_2$.\\
Una vez que tenemos la soluci\'on inicial $s$ entramos en el ciclo que se encarga de mejorarla utilizando sus vecinas.\\
Como definimos m\'as arriba, dos soluciones son vecinas si difieren en el camino de $u$ a $w$ (donde $w$ es un nodo intermedio del camino) y comparten el camino de $w$ a $v$. Entonces, en nuestro algoritmo vamos a ir recorriendo una a una las aristas de la soluci\'on inicial $s_inicial$, y, reemplazando cada una por el camino m\'inimo en $w_2$ (que ya obtuvimos al correr Floyd) entre los extremos de la misma, siempre y cuando el camino formado siga estando acotado por $K$.\\ 
As\'i, al terminar de recorrer las aristas de $s_inicial$ tenemos un camino acotado por $K$ que adem\'as es el m\'inimo de la vecindad de $s_inicial$ en $w_2$.\\

\newpage
\subsection{Algoritmo}
\subsection{Algoritmo}
\lstset{language=C++,
                basicstyle=\ttfamily\footnotesize,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
                breaklines=true
}
\begin{lstlisting}

void heuristicabl(graph* grafo, unsigned int u, unsigned int v, double k){
	
	algoritmos* algoritmo = new algoritmos();

	vector<vector<double> > pesos1_orig = grafo->get_weights1();
	vector<vector<double> > pesos2_orig = grafo->get_weights2();

	vector<vector<double> > pesos1 = grafo->get_weights1();
	vector<vector<int> > floyd1 = algoritmo->floyd(pesos1);

	/* Generacion del camino minimo para w1 */
	vector<int> camino1 = algoritmo->reconstruirPathFloyd(u,v,floyd1);

	/* Si este peso supera el K entonces no voy a encontrar uno menor,
		por lo tanto no hay solucion */
	if(!pesoEnRegla(camino1,pesos1_orig,k)) {
		cout << "no";
		return;
	}

	vector<vector<double> > pesos2 = grafo->get_weights2();
	vector<vector<int> > floyd2 = algoritmo->floyd(pesos2);
	
	/* Se recorre todo el camino c1 y para cada par de nodos se va reemplazando el tramo por el 
		camino minimo entre ese par de nodos para w2. En cada iteracion si no se supera el 
		valor de K entonces se realiza el reemplazo.*/
	unsigned int j = 0;
	while(j<camino1.size() - 1) {
		vector<int> tramoCamino2 = algoritmo->reconstruirPathFloyd(camino1[j],camino1[j+1], floyd2);
		vector<int> caminoNuevo = switchTramo(camino1, tramoCamino2, j);
		borrarRepetidos(caminoNuevo);
		if(pesoEnRegla(caminoNuevo,pesos1_orig,k)) {
			camino1 = caminoNuevo;
		}
		j++;
	}
	
	delete algoritmo;

	imprimirSolucion(camino1, pesos1_orig, pesos2_orig);
}

vector<int> switchTramo(vector<int> camino1, vector<int> tramoNuevo, int nodoSource) {
	unsigned int sizeCamino1 = camino1.size();
	unsigned int sizeTramoNuevo = tramoNuevo.size();

	vector<int> caminoNuevo = vector<int>(sizeCamino1 + sizeTramoNuevo - 2, 0);

	/* El caminoNuevo se mantiene igual que camino1 hasta la posicion indicada como nodoSource */
	for(int i=0; i<=nodoSource; i++) {
		caminoNuevo[i] = camino1[i];
	}

	/* A partir del nodoSource en adelante se agrega el tramoNuevo */
	for(int i=nodoSource+1; i<(nodoSource + sizeTramoNuevo - 1); i++) {
		caminoNuevo[i] = tramoNuevo[i-nodoSource];
	}

	/* Una vez que se completo el tramoNuevo se siguen agregando las ultimas posiciones del camino1 */
	for(unsigned int i=nodoSource+sizeTramoNuevo - 1; i<caminoNuevo.size(); i++) {
		caminoNuevo[i] = camino1[i-sizeTramoNuevo+2];
	}
	
	return caminoNuevo;
}

void borrarRepetidos(vector<int>& v) {
    int i=v.size() - 1;
    int j=i-1;
    list<int> camino;
    while(i>=0) {
        camino.push_back(v[i]);
        int aux = j;
        while(aux >= 0) {
            if(v[aux] == v[i]) {
            	j = aux-1;
            }
            aux--;
        }
        i=j;
        j--;
    }
    v = vector<int>(camino.size(), 0);
    for(unsigned int x=0; x<v.size(); x++) {
        v[x] = camino.back();
        camino.pop_back();
    }
}

\end{lstlisting}